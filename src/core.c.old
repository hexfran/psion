//typedef struct s_record 
//{
//	sds key;
//	sds content;	
//} p_record;
//
//p_record *init_empty_record_array(size_t *count, size_t *capacity);
//void insert_record(p_record *records, size_t *count, size_t capacity, p_record *value);
//p_record *search_record_by_key(p_record *records, size_t count, sds key);
//p_record *search_record_by_content(p_record *records, size_t count, sds content);
//p_record *search_record_mixed(p_record *records, size_t count, sds mixed_key_content);
//void print_records(p_record *records, size_t count);
//void free_record_array(p_record *records, size_t count);

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "core.h"

#define DEFAULT_ARR_SIZE 512

p_record *init_empty_record_array(size_t *count, size_t *capacity)
{
	p_record *arr = malloc(DEFAULT_ARR_SIZE * sizeof(p_record));

	*count = 0;
    *capacity = DEFAULT_ARR_SIZE;

	return arr;
}

void insert_record(p_record *records, size_t *count, size_t capacity, p_record *value)
{
    if((*count + 1) > capacity)
    {
        fprintf(stderr, "Error while inserting record, maximum capacity excedeed");
    }

    records[*count].key = (*value).key;
    records[*count].content = (*value).content;

    (*count)++;
}

void print_records(p_record *records, size_t count)
{
	size_t i = 0;
	ssize_t written;

	if(records == NULL)
	{
		fprintf(stderr, "records is NULL, aborting, NOT PRINTING");
		return;
	}
	
	for(i = 0; i < count; i++)
	{
        written = write(1, records[i].key, sdslen(records[i].key));
        written = write(1, "\n", 1);
        written = write(1, records[i].content, sdslen(records[i].content));
        written = write(1, "\n===\n", 5);
	}

    (void) written;
}

void free_record_array(p_record *records, size_t count)
{
    size_t i = 0;
    
    for(i = 0; i < count; i++)
	{
        sdsfree(records[i].key);
        sdsfree(records[i].content);
	}


	free(records);
}
